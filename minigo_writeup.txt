Zach Linton
Fall 2014
AI
Lab Write Up

	This quarter I attempted to implement a Minimax algorithm to play the board game Go. I had the hopes of implementing Alpha-Beta pruning on top of it, but I did not get that far. Currently, my implementation searches to a predetermined depth and returns a "best" move, or rather a "good enough" move. I was getting more moves back than I wanted, so I tried to just pick the best move from a list of all of the returned moves during the recursion. Although, while writing this I returned back to just returning the the bestValue each time. 
	My implementation currently only checks for stones in hane, atari, or 'dead' while also slightly taking into account the distances from the closest wall, the closest corner, the AI's opponent. It seems that how I am currently evaluating these together the AI does not accurately move. For instance, the AI will move into a corner or wall without the chance of a capture. Moves in which the AI takes up it's own liberties happen often as well. 
	The AI will however respond correctly from time to time and builds decent shapes. Defensively my implementation does a decent job. However, it currently is not aware of how much area it has captured. I neglected to implement the scoring, and it would seem that now would be a good time for it. There are probably many more things to implement as well. Such as end game heuristics and new game heuristics to switch up the flow of plays. 
	My implementation of Minimax mostly resides within a single function minimax(boardState, depth, maximizingPlayer, move) where maximizingPlayer is whether to use the maximizer or minimizer. The checks for distances and liberties are culminated in the h(move, board, c) function where c is the color making the move. 
	I hope to work more on this more in the future so that I can run metrics on it. However, at this point I would rather not run any metrics since if it were to play itself, it'd be a mess I think. What I can say is that it takes a long time to make a move in the beginning of the game. At a depth of 2, the first move must check 80 moves and in each of those 80 moves it checks the remaining 79 moves for its possible moves. It ends up checking 80*79*78=492960 moves just for the first move on a 9x9 board as white. So it is super slow and ineffecient, O(n!).
